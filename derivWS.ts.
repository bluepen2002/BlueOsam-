export type MessageHandler = (data: any) => void;
export type RequestId = number;
export type EventType = string;

interface QueuedMessage {
  message: string;
  handler?: MessageHandler | undefined;
}

// Use the correct WebSocket type from the browser
declare global {
  interface WebSocket {
    ping(): void;
  }
}

class DerivWS {
  private ws: WebSocket | null = null;
  private appId: string;
  private handlers: { [key: string]: MessageHandler } = {};
  private globalHandler: MessageHandler | null = null;
  private reqCounter = 1;
  private pingInterval: ReturnType<typeof setInterval> | null = null;
  private reconnectTimeout: ReturnType<typeof setTimeout> | null = null;
  private token: string | null = null;
  private messageQueue: QueuedMessage[] = [];
  private isConnected = false;
  private connectionPromise: Promise<void> | null = null;
  private reconnectAttempts = 0;
  private readonly MAX_RECONNECT_ATTEMPTS = 5;
  private readonly RECONNECT_DELAY = 2000;

  constructor(appId: string) {
    this.appId = appId;
    this.connect();
  }

  private async waitForConnection(): Promise<void> {
    if (this.isConnected) return;
    if (!this.connectionPromise) {
      this.connectionPromise = new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error('WebSocket connection timeout'));
        }, 10000);

        const checkConnection = () => {
          if (this.isConnected) {
            clearTimeout(timeout);
            resolve();
          } else {
            setTimeout(checkConnection, 100);
          }
        };
        checkConnection();
      });
    }
    return this.connectionPromise;
  }

  private handleConnectionError(error: Event) {
    console.error('WebSocket error:', error);
    this.isConnected = false;
    this.connectionPromise = null;
    this.ws?.close();
  }

  private processMessageQueue() {
    while (this.messageQueue.length > 0 && this.isConnected) {
      const { message, handler } = this.messageQueue.shift()!;
      try {
        this.ws?.send(message);
        if (handler) {
          const data = JSON.parse(message);
          if (data.req_id) {
            this.handlers[data.req_id] = handler;
          }
        }
      } catch (error) {
        console.error('Error processing queued message:', error);
      }
    }
  }

  connect() {
    if (this.ws?.readyState === WebSocket.OPEN) return;

    try {
      this.ws = new WebSocket(`wss://ws.derivws.com/websockets/v3?app_id=${this.appId}`) as WebSocket;
      this.isConnected = false;
      this.connectionPromise = null;

      if (this.ws) {
        this.ws.onopen = () => {
          this.isConnected = true;
          this.reconnectAttempts = 0;
          this.startPing();
          if (this.token) {
            this.authorize(this.token);
          }
          this.processMessageQueue();
        };

        this.ws.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            if (data.req_id && this.handlers[data.req_id]) {
              const handler = this.handlers[data.req_id];
              if (handler) {
                handler(data);
                // Clean up one-time handlers
                delete this.handlers[data.req_id];
              }
            } else if (this.globalHandler) {
              this.globalHandler(data);
            }
          } catch (error) {
            console.error('Error processing message:', error);
          }
        };

        this.ws.onclose = () => {
          this.isConnected = false;
          this.stopPing();
          this.connectionPromise = null;
          
          if (this.reconnectAttempts < this.MAX_RECONNECT_ATTEMPTS) {
            this.reconnectAttempts++;
            this.reconnectTimeout = setTimeout(
              () => this.connect(),
              this.RECONNECT_DELAY * this.reconnectAttempts
            );
          } else {
            console.error('Max reconnection attempts reached');
          }
        };

        this.ws.onerror = this.handleConnectionError.bind(this);
      }
    } catch (error) {
      console.error('Error creating WebSocket connection:', error);
      this.handleConnectionError(error as Event);
    }
  }

  async send(request: object, handler?: MessageHandler): Promise<RequestId> {
    const req_id = this.reqCounter++;
    const msg = { ...request, req_id };
    const messageStr = JSON.stringify(msg);
    
    try {
      await this.waitForConnection();
      this.ws?.send(messageStr);
      if (handler) {
        this.handlers[req_id] = handler;
      }
    } catch (error) {
      console.warn('WebSocket not ready, queueing message:', error);
      this.messageQueue.push({ message: messageStr, handler });
    }

    return req_id;
  }

  async subscribe(request: object, handler: MessageHandler): Promise<RequestId> {
    return this.send({ ...request, subscribe: 1 }, handler);
  }

  setGlobalHandler(handler: MessageHandler) {
    this.globalHandler = handler;
  }

  async authorize(token: string) {
    this.token = token;
    await this.send({ authorize: token });
  }

  startPing() {
    this.pingInterval = setInterval(() => {
      this.send({ ping: 1 });
    }, 60000); // Ping every 60 seconds
  }

  stopPing() {
    if (this.pingInterval) {
      clearInterval(this.pingInterval);
      this.pingInterval = null;
    }
  }

  close() {
    this.stopPing();
    if (this.reconnectTimeout) {
      clearTimeout(this.reconnectTimeout);
      this.reconnectTimeout = null;
    }
    this.ws?.close();
    this.isConnected = false;
    this.connectionPromise = null;
    this.messageQueue = [];
    this.handlers = {};
    this.globalHandler = null;
  }

  on(type: EventType, handler: MessageHandler) {
    this.handlers[type] = handler;
  }

  off(type: EventType) {
    delete this.handlers[type];
  }
}

export default DerivWS; 
